A thread is a basic unit of CPU utilization, consisting of a program counter, a stack, and a set of registers, ( and a thread ID. )
Traditional ( heavyweight ) processes have a single thread of control - There is one program counter, and one sequence of instructions that can be carried out at any given time.

Kernel-Level Threads:To make concurrency cheaper, the execution aspect of process is separated out into threads. As such, the OS now manages threads and processes. All thread operations are implemented in the kernel and the OS schedules all threads in the system. OS managed threads are called kernel-level threads or light weight processes.NT: ThreadsSolaris: Lightweight processes(LWP).
In this method, the kernel knows about and manages the threads. No runtime system is needed in this case. Instead of thread table in each process, the kernel has a thread table that keeps track of all threads in the system. In addition, the kernel also maintains the traditional process table to keep track of processes. Operating Systems kernel provides system call to create and manage threads.

advantages:-Because kernel has full knowledge of all threads, Scheduler may decide to give more time to a process having large number of threads than process having small number of threads.Kernel-level threads are especially good for applications that frequently block.diadvantages:-The kernel-level threads are slow and inefficient. For instance, threads operations are hundreds of times slower than that of user-level threads.Since kernel must manage and schedule threads as well as processes. It require a full thread control block (TCB) for each thread to maintain information about threads. As a result there is significant overhead and increased in kernel complexity.

User-Level Threads ;Kernel-Level threads make concurrency much cheaper than process because, much less state to allocate and initialize. However, for fine-grained concurrency, kernel-level threads still suffer from too much overhead. Thread operations still require system calls. Ideally, we require thread operations to be as fast as a procedure call. Kernel-Level threads have to be general to support the needs of all programmers, languages, runtimes, etc. For such fine grained concurrency we need still "cheaper" threads.

      To make threads cheap and fast, they need to be implemented at user level. User-Level threads are managed entirely by the run-time system (user-level library).The kernel knows nothing about user-level threads and manages them as if they were single-threaded processes.User-Level threads are small and fast, each thread is represented by a PC,register,stack, and small thread control block. Creating a new thread, switiching between threads, and synchronizing threads are done via procedure call. i.e no kernel involvement. User-Level threads are hundred times faster than Kernel-Level threads.

Advantages:-The most obvious advantage of this technique is that a user-level threads package can be implemented on an Operating System that does not support threads.User-level threads does not require modification to operating systems.Simple Representation: Each thread is represented simply by a PC, registers, stack and a small control block, all stored in the user process address space.Simple Management:  This simply means that creating a thread, switching between threads and synchronization between threads can all be done without intervention of the kernel.Fast and Efficient:  Thread switching is not much more expensive than a procedure call.

Disadvantages:- User-Level threads are not a perfect solution as with everything else, they are a trade off. Since, User-Level threads are invisible to the OS they are not well integrated with the OS. As a result, Os can make poor decisions like scheduling a process with idle threads, blocking a process whose thread initiated an I/O even though the process has other threads that can run and unscheduling a process with a thread holding a lock. Solving this requires communication between between kernel and user-level thread manager.There is a lack of coordination between threads and operating system kernel. Therefore, process as whole gets one time slice irrespect of whether process has one thread or 1000 threads within. It is up to each thread to relinquish control to other threads.User-level threads requires non-blocking systems call i.e., a multithreaded kernel. Otherwise, entire process will blocked in the kernel, even if there are runable threads left in the processes. For example, if one thread causes a page fault, the process blocks.


main difference is Users implement the user-level threads. On the other hand, the OS implements kernel-level threads.
User-level threads may be created and handled much faster. In contrast, kernel-level threads take longer to create and maintain.The entire process is halted if a single user-level thread carries out a blocking operation. On the other hand, if a kernel thread carries out a blocking operation, another thread may continue to run.The user-level thread library includes the source code for thread creation, data transfer, thread destruction, message passing, and thread scheduling. On the other hand, the application code on kernel-level threads does not include thread management code. It is simply an API to the kernel mode.User-level threads do not invoke system calls for scheduling. On the other hand, system calls are used to generate and manage threads at the kernel level.The user-level thread is also referred to as the many-to-one mapping thread, as the OS assigns each thread in a multithreaded process to an execution context. 